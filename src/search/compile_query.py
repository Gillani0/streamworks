#!/usr/bin/python
import os
import sys
import re

gen_vertex_filter = False
gen_edge_filter = False
vertex_filter_list = []
edge_filter_list = []

class GraphSchema:
    def __init__(self, file):
        m = re.search('(\w+).schema', file)
        self.schema_name = m.group(1)
        self.vertex_class = ''
        self.edge_class = ''
        self.vertex_schema = dict()
        self.edge_schema = dict()
        self.fn_map = dict()
        self.fn_map['=='] = 'EQ'
        self.fn_map['!='] = 'NEQ'
        self.fn_map['<'] = 'LT'
        self.fn_map['>'] = 'GT'
        #self.fn_map['~='] = 'RegexMatch'

        path = 'schema_' + self.schema_name + '.h'
        if os.path.exists(path):
            os.system('rm ' + path)

        f = open(file, 'r')
        for line in f:
            line = line.strip()
            if len(line) == 0 or line[0] == '#':
                continue
            if line.find('entity') != -1:
                parse_vertex = True 
                self.vertex_class = (line.split(' '))[1]
                continue
            elif line.find('relation') != -1:
                parse_vertex = False
                self.edge_class = (line.split(' '))[1]
                continue
            
            tokens = line.strip().split(' ')
            if parse_vertex:
                self.vertex_schema[tokens[1]] = tokens[0]
            else:
                self.edge_schema[tokens[1]] = tokens[0]
        f.close()

    def get_class(self, is_vertex):
        if is_vertex:
            return self.vertex_class
        else:
            return self.edge_class

    def get_name(self):
        return self.schema_name

    def get_fn(self, op):
        try:
            return self.fn_map[op]
        except KeyError:
            return None
    
    def get_att_type(self, is_vertex, att_name):
        att_type = ''
        if is_vertex:
            if att_name == 'deg':
                return 'int'
            elif att_name == 'label':
                return 'string'
            else:
                print('Unknown attribute = [' + att_name + ']')
                raise TypeError('Only label/degree filters allowed for nodes')
            #try:
                #att_type =  self.vertex_schema[att_name]
            #except KeyError:
                #print('Unknown vertex attb: ' + att_name)
                #sys.exit(1)
        else:
            try:
                att_type =  self.edge_schema[att_name]
            except KeyError:
                print('Unknown edge attb: ' + att_name)
                sys.exit(1)
        return att_type

    def store_cpp_header(self):
        
        outfile = 'schema_' + self.schema_name + '.h'
        f = open(outfile, 'w')
        f.write('/*\n * Generated by ' + __file__ + '\n */\n')
        f.write('#ifndef __SCHEMA_' + self.schema_name + '_H__\n')
        f.write('#define __SCHEMA_' + self.schema_name + '_H__\n\n')
        f.write('#include "graph.hpp"\n\n')

        if self.vertex_class != 'Label':
            f.write('struct ' + self.vertex_class + ' {\n')
            for att_name in self.vertex_schema:
                att_type = self.vertex_schema[att_name]
                f.write('    ' + att_type + ' ' + att_name + ';\n')
            f.write('    bool FilterVertex(int vertex_id);\n')
            f.write('};\n\n')

        f.write('struct ' + self.edge_class + ' {\n')
        for att_name in self.edge_schema:
            att_type = self.edge_schema[att_name]
            f.write('    ' + att_type + ' ' + att_name + ';\n')
        f.write('    bool FilterEdge(int edge_id) const;\n')
        f.write('};\n\n')
        f.write('typedef Graph<' + self.vertex_class + ',' + \
            self.edge_class + '> StreamG;\n\n')
        f.write('#endif\n')
        f.close()
        
def gen_filter_header(schema, query_id):
    outfile = 'query_mod_' + schema.get_name() + '_' + query_id + '.cc'
    if os.path.exists(outfile) == False:
        f = open(outfile, 'w')
        header = 'schema_' + schema.get_name() + '.h'
        f.write('/*\n * Generated by ' + __file__ + '\n */\n')
        f.write('#include "' + header + '"\n')
        f.write('#include "vertex.hpp"\n')
        f.write('#include "filters.hpp"\n')
        f.write('using namespace std;\n\n')
        f.close()
    return

def gen_filter_function(schema, query_id, is_vertex, id, filter_list):
    
    global gen_vertex_filter
    global gen_edge_filter

    outfile = 'query_mod_' + schema.get_name() + '_' + query_id + '.cc'
    f = open(outfile, 'a')

    if is_vertex:
        vertex_filter_list.append(id)
        f.write('inline bool filter_vertex_' + str(id) + \
            '(int deg, const string& label)\n')
            #'(const VertexProperty<' + schema.get_class(True) + \
            #'>& v_prop)\n')
        arg_type = ''
        gen_vertex_filter = True
    else:
        edge_filter_list.append(id)
        f.write('inline bool filter_edge_' + str(id) + \
            '(const ' + schema.get_class(False) + \
            '& edge_data)\n')
        arg_type = 'edge_data.'
        gen_edge_filter = True

    f.write('{\n')

    for filter in filter_list:
        op = filter[0]
        fn_name = schema.get_fn(op)
        if fn_name == None:
            continue
        tokens = filter[1].split(op)
        att_name = tokens[0]
        att_value = tokens[1]
        att_type = schema.get_att_type(is_vertex, att_name)
        if fn_name != 'RegexMatch':
            fn_name = fn_name + '<' + att_type + '>'
        #f.write('    if(' + fn_name + '<' + att_type + '>' \
        f.write('    if(' + fn_name \
            + '(' + arg_type + att_name + ', ' + \
            att_value + ')) {\n')
        f.write('        return true;\n')
        f.write('    }\n')

    f.write('    return false;\n\n')
    f.write('}\n\n')
    f.close()

def parse_filter(schema, query_id, is_vertex, id, tokens):
    filter_list = []
    op_list = ['==', '!=', '<', '>', '~=']
    if is_vertex:
        start_offset = 3
    else:
        start_offset = 4

    for i in range(start_offset,len(tokens)):
        filter = tokens[i];
        for op in op_list:
            if filter.find(op) != -1:
                print('Adding filter = ' + filter)
                filter_list.append([op, filter])
                continue

    if len(filter_list) > 0:
        gen_filter_function(schema, query_id, is_vertex, id, filter_list)

def gen_filter_handler(schema, query_id):
    global gen_vertex_filter
    global gen_edge_filter
    #if gen_vertex_filter == False and gen_edge_filter == False:
    #    return 

    outfile = 'query_mod_' + schema.get_name() + '_' + query_id + '.cc'
    f = open(outfile, 'a')
    
    # generate FilterVertex() 
    f.write('bool Label :: FilterVertex(int u, int deg, const Label& label) const\n')
    #f.write('bool FilterVertex(int u, VertexProperty<' \#+ schema.get_class(True) + '>& v_prop)\n')
    f.write('{\n')
    if gen_vertex_filter:
        f.write('    switch(u) {\n')
        for u in sorted(vertex_filter_list):
            f.write('        case ' + str(u) + ': return filter_vertex_' \
                + str(u) + '(deg, label.label);\n')
        f.write('        default: return true;\n')
        f.write('    }\n')
    else:
        f.write('    return true;\n')
    f.write('}\n\n')

        
        # generate FilterEdge()
    f.write('bool ' + schema.get_class(False) + \
            ' :: FilterEdge(int edge_id) const\n')
    #f.write('bool FilterEdge(int eid, EdgeProperty<' \
            #+ schema.get_class(False) + '>& e_prop)\n')
    f.write('{\n')
    if gen_edge_filter:

        f.write('    switch(edge_id) {\n')
        for eid in sorted(edge_filter_list):
            f.write('        case ' + str(eid) + ': return filter_edge_' \
                + str(eid) + '(*this);\n')
        f.write('        default: return true;\n')
        f.write('    }\n')
    else:
        f.write('    return true;\n')
    f.write('}\n\n')
    f.close()

def parse_query(schema, file):
    print('Parsing query file: ' + file)
    m = re.match('(\w+).graph', os.path.basename(file))
    query_id = m.group(1)

    outfile = 'query_mod_' + schema.get_name() + '_' + query_id + '.cc'
    if os.path.exists(outfile):
        os.system('rm ' + outfile)

    f = open(file, 'r')
    vertex_id = 0
    edge_id = 0

    gen_filter_header(schema, query_id)

    for line in f:
        if len(line) == 0 or (line[0] != 'v' and line[0] != 'e'):
            continue
        #if len(line) == 0 or line[0] == '#':
            #continue
        if line[0] == 'e':
            edge_desc = True
            edge_id += 1
        else:
            edge_desc = False
            vertex_id += 1
        tokens = line.strip().split(' ')
        if edge_desc:
            if len(tokens) == 4:
                # e u v e_type filter1 filter2 ...
                continue
            else:
                parse_filter(schema, query_id, False, edge_id-1, tokens)
        else:
            if len(tokens) == 3:
                continue
            else:
                # v u v_type filter1 filter2 ...
                parse_filter(schema, query_id, True, vertex_id-1, tokens)
                
    f.close()
    gen_filter_handler(graph_schema, query_id)

def parse_schema(file, vertex_atts, edge_atts):
    f = open(file, 'r')
    for line in f:
        tokens = line.strip().split(' ')
        att_type = tokens[1]
        att_name = tokens[2]
        for t in tokens:
            print(t)
    f.close()

if len(sys.argv) < 3:
    print('USAGE:')
    print(sys.argv[0] + ' <schema_file_path> <query_file_path>')
    print('---------------------------------')
    print('EXAMPLE SCHEMA FILE')
    print('---------------------------------')
    os.system('cat netflow.schema')
    print('---------------------------------')
    print('EXAMPLE QUERY FILE')
    print('---------------------------------')
    os.system('cat query.graph')
    sys.exit(1)

schema_path = sys.argv[1]
query_path = sys.argv[2]

graph_schema = GraphSchema(schema_path) #'netflow.schema')
graph_schema.store_cpp_header()
parse_query(graph_schema, query_path) #'query.graph')
